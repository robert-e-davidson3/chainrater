import {
  createWalletClient,
  createPublicClient,
  http,
  custom,
  getContract,
  type WalletClient,
  type PublicClient,
  type Chain,
  type Address,
  ContractEventName,
  ContractEventArgs,
} from "viem";
import { mainnet, sepolia, foundry } from "viem/chains";
import { hashURI } from "../utils/blockchain.utils.js";
import "viem/window";

// Import the deployments file
// This will be automatically generated by the build script
import deploymentsRaw from "../../src/deployments.json" with { type: "json" };
const deployments = { ...deploymentsRaw } as const;

// type Contract =
// (typeof deployments.contracts)[keyof typeof deployments.contracts];

// Supported chains
const chains = [mainnet, sepolia, foundry];
type CHAIN_IDS = (typeof chains)[number]["id"];
// type CHAIN_IDS = `${(typeof chains)[number]["id"]}`;

export class BlockchainService {
  // Singleton instance
  private static instance: BlockchainService;

  private walletClient: WalletClient | null = null;
  private publicClient: PublicClient | null = null;
  private account: Address | null = null;
  private chain: Chain | null = null;
  private readonly cache: Cache = new Cache();

  private watchers: {
    UriRevealed?: () => void;
    RatingSubmitted?: () => void;
    RatingReSubmitted?: () => void;
    RatingRemoved?: () => void;
    RatingCleanedUp?: () => void;
  } = {};

  private accountListeners: Set<() => void> = new Set();
  private chainListeners: Set<() => void> = new Set();
  private ratingsListeners: Set<() => void> = new Set();

  private constructor() {
    // Setup event listeners for MetaMask etc
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", (accounts: string[]) => {
        console.log("Account changed:", accounts[0]);
        this.account = (accounts[0] as Address) || null;
        this.notifyAccountListeners();
      });

      window.ethereum.on("chainChanged", (chainIdHex: string) => {
        console.log("Chain changed:", chainIdHex);
        const chainId = parseInt(chainIdHex, 16);
        // TODO handle the change without bad state
        //      1. tell watchers to stop
        //      2. wait for them to do so (if needed)
        //      3. wipe cache and hashToURI
        this.setChain(chainId);
        this.notifyChainListeners();
      });
    }
  }

  async getRatings(filter: GetRatingsFilter): Promise<Rating[]> {
    if (!this.isConnected() || !this.chain) throw new Error("Not connected");
    if (filter.expired !== undefined) await this.stakePerSecond();
    return this.cache.getRatings(filter);
  }

  URIFromHash(uriHash: string): string | undefined {
    return this.cache.getHashForURI(uriHash);
  }

  setChain(chainId: number): void {
    this.cache.clear();

    const currentChain = chains.find((chain) => chain.id === chainId);
    if (!currentChain) {
      this.chain = null;
      throw new Error(`Chain not found: ${chainId}`);
    }

    this.chain = currentChain;

    this.publicClient = createPublicClient({
      chain: currentChain,
      transport: http(),
    });

    if (window.ethereum)
      this.walletClient = createWalletClient({
        chain: currentChain,
        transport: custom(window.ethereum),
      });
  }

  public static getInstance(): BlockchainService {
    if (!BlockchainService.instance) {
      BlockchainService.instance = new BlockchainService();
    }
    return BlockchainService.instance;
  }

  private notifyAccountListeners() {
    this.accountListeners.forEach((listener) => listener());
  }

  private notifyChainListeners() {
    this.chainListeners.forEach((listener) => listener());
  }

  notifyRatingsListeners() {
    this.ratingsListeners.forEach((listener) => listener());
  }

  public onAccountChanged(listener: () => void): () => void {
    this.accountListeners.add(listener);
    return () => this.accountListeners.delete(listener);
  }

  public onChainChanged(listener: () => void): () => void {
    this.chainListeners.add(listener);
    return () => this.chainListeners.delete(listener);
  }

  public onRatingsChanged(listener: () => void): () => void {
    this.ratingsListeners.add(listener);
    return () => this.ratingsListeners.delete(listener);
  }

  get ratingsContract() {
    if (!this.isConnected() || !this.chain) throw new Error("Not connected");

    const abi = deployments.contracts.Ratings.abi;
    const address = addressOrThrow(
      deployments.contracts.Ratings.addresses,
      this.chain.id,
    );

    return getContract({
      address,
      abi,
      client: this.getClientForContract(),
    });
  }

  private getClientForContract() {
    let client;
    if (this.publicClient && this.walletClient)
      client = {
        public: this.publicClient,
        wallet: this.walletClient,
      };
    else if (this.publicClient) client = this.publicClient;
    else if (this.walletClient) client = this.walletClient;
    else throw new Error("No client available");
    return client;
  }

  // Connection methods
  async connect(): Promise<string> {
    if (!window.ethereum) {
      throw new Error("MetaMask or compatible wallet is required");
    }

    // Create wallet client with MetaMask provider
    this.walletClient = createWalletClient({
      transport: custom(window.ethereum),
    });

    // Request accounts
    const accounts = await this.walletClient.requestAddresses();
    this.account = accounts[0];

    if (!this.account) {
      throw new Error("No accounts found");
    }

    // Get chain ID
    const chainId = await window.ethereum
      .request({ method: "eth_chainId" })
      .then((chainIdHex) => parseInt(chainIdHex as string, 16));

    this.setChain(chainId);

    await Promise.all([this.minStake(), this.stakePerSecond()]);

    if (!this.publicClient) throw new Error("No public client available");

    this.watchers.UriRevealed = RatingsContract.handleEvent(
      this.publicClient,
      "UriRevealed",
      {},
      (logs) => {
        if (!this.isConnected()) return;
        for (const log of logs) {
          const { uriHash, uri } = (log as any).args as Log.UriRevealed;
          this.cache.setURIHash(uri, uriHash);
        }
      },
    );

    const handleAdderLogs = (logs: any[]) => {
      if (!this.isConnected()) return;
      let ratingsChanged = false;

      for (const log of logs) {
        const { blockNumber } = log;
        const {
          uri: uriHash,
          rater,
          score,
          stake,
        } = log.args as Log.RatingSubmitted;

        const rating = this.cache.getRatings({ uriHash, rater })[0];

        if (!rating || rating.latestBlockNumber < blockNumber) {
          this.cache.setRating({
            uriHash,
            rater,
            score,
            stake,
            latestBlockNumber: blockNumber,
            posted: stake,
            deleted: false,
          });
          ratingsChanged = true;
        }
      }

      if (ratingsChanged) {
        this.notifyRatingsListeners();
      }
    };

    const handleRemoverLogs = (logs: any[]) => {
      if (!this.isConnected()) return;
      let ratingsChanged = false;

      for (const log of logs) {
        const { blockNumber }: { blockNumber: bigint } = log;
        const { uri: uriHash, rater } = log.args as Log.RatingRemoved;

        const rating = this.cache.getRatings({ uriHash, rater })[0];

        if (!rating || rating.latestBlockNumber < blockNumber) {
          this.cache.setRating({
            uriHash,
            rater,
            latestBlockNumber: blockNumber,
            deleted: true,
          });
          ratingsChanged = true;
        }
      }

      if (ratingsChanged) {
        this.notifyRatingsListeners();
      }
    };

    this.watchers.RatingSubmitted = RatingsContract.handleEvent(
      this.publicClient,
      "RatingSubmitted",
      {},
      handleAdderLogs,
    );
    this.watchers.RatingReSubmitted = RatingsContract.handleEvent(
      this.publicClient,
      "RatingReSubmitted",
      {},
      handleAdderLogs,
    );
    this.watchers.RatingRemoved = RatingsContract.handleEvent(
      this.publicClient,
      "RatingRemoved",
      {},
      handleRemoverLogs,
    );
    this.watchers.RatingCleanedUp = RatingsContract.handleEvent(
      this.publicClient,
      "RatingCleanedUp",
      {},
      handleRemoverLogs,
    );

    return this.account;
  }

  async disconnect(): Promise<void> {
    this.walletClient = null;
    this.account = null;
    this.notifyAccountListeners();
  }

  isConnected(): boolean {
    return !!this.account && !!this.walletClient && !!this.chain;
  }

  get address(): Address | null {
    return this.account;
  }

  get chainId(): number | null {
    return this.chain?.id ?? null;
  }

  async stakePerSecond(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.stakePerSecond) return this.cache.stakePerSecond;

    const contract = this.ratingsContract;

    return contract.read.STAKE_PER_SECOND([]) as unknown as bigint;
  }

  async minStake(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.minStake) return this.cache.minStake;

    const contract = this.ratingsContract;

    return contract.read.MIN_STAKE([]) as unknown as bigint;
  }

  async submitRating(uri: string, score: number, stake: bigint) {
    if (!this.isConnected() || !this.ratingsContract || !this.chain)
      throw new Error("Not connected");

    const txHash = await this.ratingsContract.write.submitRating([uri, score], {
      value: stake,
      chain: this.chain,
      account: this.account,
    });
    await this.publicClient?.waitForTransactionReceipt({ hash: txHash });
  }

  async removeRating(uri: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.removeRating([uriHash], {
      chain: this.chain,
      account: this.account,
    });
  }

  async cleanupRating(uri: string, rater: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.cleanupRating([uriHash, rater], {
      chain: this.chain,
      account: this.account,
    });
  }

  async getRating(
    uri: string,
    rater: Address,
  ): Promise<Omit<ExistingRating, "latestBlockNumber"> | null> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    const contract = this.ratingsContract;

    const uriHash = hashURI(uri);

    const { score, posted, stake } = (await contract.read.getRating([
      uriHash,
      rater,
    ])) as unknown as RatingStruct;

    const stakePerSecond = await this.stakePerSecond();
    const stakeInWei = stake * stakePerSecond;

    return {
      uriHash,
      decodedURI: uri,
      score,
      posted,
      stake: stakeInWei,
      rater,
      deleted: false,
    };
  }
}

class Cache {
  minStake?: bigint;
  stakePerSecond?: bigint;
  private hashToURI: Map<string, string> = new Map();
  // URI hash -> rater address -> Rating
  private ratings: Map<string, Map<Address, Rating>> = new Map();

  clear() {
    this.minStake = undefined;
    this.stakePerSecond = undefined;
    this.hashToURI.clear();
    this.ratings.clear();
  }

  setURIHash(uri: string, hash?: string) {
    hash = hash ?? hashURI(uri);
    hash = hash.toLowerCase();
    this.hashToURI.set(hash, uri);
  }

  getHashForURI(uriHash: string): string | undefined {
    return this.hashToURI.get(uriHash);
  }

  setRating(rating: Rating) {
    rating.uriHash = rating.uriHash.toLowerCase();
    rating.rater = rating.rater.toLowerCase() as Address;
    if (!this.ratings.has(rating.uriHash))
      this.ratings.set(rating.uriHash, new Map());
    const raterMap = this.ratings.get(rating.uriHash) as Map<Address, Rating>;
    raterMap.set(rating.rater, rating);
  }

  getRatings({
    uriHash,
    uri,
    rater,
    expired,
    deleted,
  }: GetRatingsFilter): Rating[] {
    if (expired !== undefined && deleted !== false)
      throw new Error("Cannot filter by both expired if deleted != false");

    if (uri !== undefined && uriHash === undefined) uriHash = hashURI(uri);

    if (uriHash) uriHash = uriHash.toLowerCase();
    if (rater) rater = rater.toLowerCase() as Address;

    let ratings: Rating[] = [];
    if (uriHash && rater) {
      const rating = this.ratings.get(uriHash)?.get(rater);
      if (rating) ratings.push(rating);
    } else if (uriHash) {
      const raterMap = this.ratings.get(uriHash);
      if (raterMap) ratings = Array.from(raterMap.values());
    } else if (rater) {
      this.ratings.forEach((raterMap) => {
        const rating = raterMap.get(rater);
        if (rating) ratings.push(rating);
      });
    } else {
      this.ratings.forEach((raterMap) => {
        ratings.push(...Array.from(raterMap.values()));
      });
    }

    if (deleted !== undefined)
      ratings = ratings.filter((rating) => rating.deleted === deleted);

    if (expired !== undefined) {
      const stakePerSecond = this.stakePerSecond;
      if (stakePerSecond === undefined) throw Error("stakePerSecond not set");
      const now = new Date(); // TODO must be same tz etc as blockchain
      ratings = ratings.filter((rating) => {
        const { posted, stake } = rating as ExistingRating;
        const expirationTime = calculateExpirationTime(
          posted,
          stake,
          stakePerSecond,
        );
        return expired ? expirationTime < now : expirationTime >= now;
      });
    }

    return ratings;
  }
}

type GetRatingsFilter = {
  uriHash?: string;
  uri?: string;
  rater?: Address;
  expired?: boolean;
  deleted?: boolean;
};

namespace RatingsContract {
  export function handleEvent<
    ABI extends typeof deployments.contracts.Ratings.abi,
  >(
    publicClient: PublicClient,
    eventName: ContractEventName<ABI>,
    args: ContractEventArgs<ABI, typeof eventName>,
    handleLogs: (logs: any[]) => Promise<void> | void,
  ): () => void {
    const chain = publicClient.chain;
    if (!chain) throw new Error("No chain connected");

    const abi = deployments.contracts.Ratings.abi;
    const address = addressOrThrow(
      deployments.contracts.Ratings.addresses,
      chain.id,
    );

    // First, watch for new events
    const stopWatching = publicClient.watchContractEvent({
      abi,
      address,
      eventName,
      args,
      strict: true,
      onLogs: (logs) => {
        handleLogs(logs);
      },
    });

    // Then, get the historical events
    publicClient
      ?.getContractEvents({
        abi,
        address,
        fromBlock: "earliest",
        toBlock: "latest",
        eventName,
      })
      .then((logs) => {
        handleLogs(logs);
        // Notify ratings listeners after processing historical logs
        if (
          logs.length > 0 &&
          BlockchainService.getInstance().notifyRatingsListeners
        ) {
          BlockchainService.getInstance().notifyRatingsListeners();
        }
      });

    return stopWatching;
  }
}

function isChainId(id: number): id is CHAIN_IDS {
  return chains.some((chain) => chain.id === id);
}

function addressOrThrow(addresses: any, id: number): Address {
  if (!isChainId(id)) throw new Error(`Invalid chain ID: ${id}`);

  if (typeof addresses !== "object")
    throw new Error("Invalid deployments file format");
  const addrs = addresses as { [k: string]: Address };
  const address = addrs[String(id)];
  if (!address) throw new Error(`Contract not deployed on network ${id}`);
  if (typeof address !== "string")
    throw new Error("Invalid deployments file format");
  if (!address.startsWith("0x"))
    throw new Error("Invalid deployments file format");
  return address;
}

export function calculateExpirationTime(
  posted: bigint,
  stake: bigint,
  stakePerSecond: bigint,
): Date {
  const expirationTimeInSeconds =
    Number(posted) + Number(stake) / Number(stakePerSecond);
  return new Date(expirationTimeInSeconds * 1000);
}

namespace Log {
  export type UriRevealed = {
    uriHash: string;
    uri: string;
  };
  // Also works for RatingReSubmitted
  export type RatingSubmitted = {
    uri: string; // actually the hash
    rater: Address;
    score: number;
    stake: bigint;
  };
  // Also works for RatingCleanedUp
  export type RatingRemoved = {
    uri: string; // actually the hash
    rater: Address;
  };
}

interface RatingStruct {
  score: number;
  posted: bigint;
  stake: bigint;
}

export type Rating = ExistingRating | DeletedRating;

export interface ExistingRating {
  uriHash: string;
  decodedURI?: string; // TODO needed?
  score: number;
  posted: bigint;
  stake: bigint;
  rater: Address;
  // expirationTime: Date; // TODO derive at-need
  latestBlockNumber: bigint;
  deleted: false;
}

export interface DeletedRating {
  uriHash: string;
  rater: Address;
  latestBlockNumber: bigint;
  deleted: true;
}

export interface SearchResult {
  uriHash: string;
  decodedURI?: string;
  averageScore: number;
  ratingCount: number;
  topRatings?: Rating[];
  isExpired?: boolean;
  stake?: string;
  expirationTime?: Date;
  rater?: Address;
}

export interface RatingLog {
  uriHash: string;
  rater: Address;
  score: number;
  stake: bigint;
  blockNumber: bigint;
  add: boolean; // true if Rating(Re)Submitted, false otherwise
}
