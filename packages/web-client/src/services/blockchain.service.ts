import {
  createWalletClient,
  createPublicClient,
  http,
  custom,
  getContract,
  type WalletClient,
  type PublicClient,
  type Chain,
  type Address,
} from "viem";
import { mainnet, sepolia, localhost } from "viem/chains";
import { hashURI } from "../utils/blockchain.utils.js";
import "viem/window";

// Import the deployments file
// This will be automatically generated by the build script
// @ts-ignore - This file will be generated at build time
import deployments from "../../src/deployments.json";

// Supported chains
const chains = [mainnet, sepolia, localhost];

export class BlockchainService {
  // Singleton instance
  private static instance: BlockchainService;

  private walletClient: WalletClient | null = null;
  private publicClient: PublicClient | null = null;
  private account: Address | null = null;
  private chain: Chain | null = null;
  private cache?: { minStake: bigint; stakePerSecond: bigint };

  private accountListeners: Set<() => void> = new Set();
  private chainListeners: Set<() => void> = new Set();

  private constructor() {
    // Setup event listeners for MetaMask etc
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", (accounts: string[]) => {
        console.log("Account changed:", accounts[0]);
        this.account = (accounts[0] as Address) || null;
        this.notifyAccountListeners();
      });

      window.ethereum.on("chainChanged", (chainIdHex: string) => {
        console.log("Chain changed:", chainIdHex);
        const chainId = parseInt(chainIdHex, 16);
        this.setChain(chainId);
        this.notifyChainListeners();
      });
    }
  }

  setChain(chainId: number): void {
    this.cache = undefined;

    const currentChain = chains.find((chain) => chain.id === chainId);
    if (!currentChain) {
      this.chain = null;
      throw new Error(`Chain not found: ${chainId}`);
    }

    this.chain = currentChain;

    this.publicClient = createPublicClient({
      chain: currentChain,
      transport: http(),
    });

    if (window.ethereum)
      this.walletClient = createWalletClient({
        chain: currentChain,
        transport: custom(window.ethereum),
      });
  }

  public static getInstance(): BlockchainService {
    if (!BlockchainService.instance) {
      BlockchainService.instance = new BlockchainService();
    }
    return BlockchainService.instance;
  }

  private notifyAccountListeners() {
    this.accountListeners.forEach((listener) => listener());
  }

  private notifyChainListeners() {
    this.chainListeners.forEach((listener) => listener());
  }

  public onAccountChanged(listener: () => void): () => void {
    this.accountListeners.add(listener);
    return () => this.accountListeners.delete(listener);
  }

  public onChainChanged(listener: () => void): () => void {
    this.chainListeners.add(listener);
    return () => this.chainListeners.delete(listener);
  }

  get ratingsContract() {
    if (!this.isConnected() || !this.chain) throw new Error("Not connected");

    const contractInfo = this.getContractInfo("Ratings", this.chain.id);
    if (!contractInfo)
      throw Error(`ChainRater is not deployed on network ${this.chain.id}`);
    const { address, abi } = contractInfo;

    let client;
    if (this.publicClient && this.walletClient)
      client = {
        public: this.publicClient,
        wallet: this.walletClient,
      };
    else if (this.publicClient) client = this.publicClient;
    else if (this.walletClient) client = this.walletClient;
    else throw new Error("No client available");

    return getContract({
      address,
      abi,
      client,
    });
  }

  // Connection methods
  async connect(): Promise<string> {
    if (!window.ethereum) {
      throw new Error("MetaMask or compatible wallet is required");
    }

    try {
      // Create wallet client with MetaMask provider
      this.walletClient = createWalletClient({
        transport: custom(window.ethereum),
      });

      // Request accounts
      const accounts = await this.walletClient.requestAddresses();
      this.account = accounts[0];

      if (!this.account) {
        throw new Error("No accounts found");
      }

      // Get chain ID
      const chainId = await window.ethereum
        .request({ method: "eth_chainId" })
        .then((chainIdHex) => parseInt(chainIdHex as string, 16));

      this.setChain(chainId);

      return this.account;
    } catch (error) {
      console.error("Connection error:", error);
      throw error;
    }
  }

  private getContractInfo(
    contractName: string,
    chainId: number,
  ): ContractDeploymentInfo | null {
    const { contracts } = deployments;
    if (!Object.keys(contracts).includes(contractName)) return null;
    const contract = (contracts as any)[contractName] as ContractInfo;

    const { addresses, abi } = contract;
    if (!Object.keys(addresses).includes(String(chainId))) return null;
    const address = addresses[chainId] as Address;

    return { address, abi };
  }

  async disconnect(): Promise<void> {
    this.walletClient = null;
    this.account = null;
    this.notifyAccountListeners();
  }

  isConnected(): boolean {
    return !!this.account && !!this.walletClient && !!this.ratingsContract;
  }

  getAddress(): string | null {
    return this.account;
  }

  get chainId(): number | null {
    return this.chain?.id ?? null;
  }

  async stakePerSecond(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.stakePerSecond) return this.cache.stakePerSecond;

    const contract = this.ratingsContract;

    const result = await contract.read.STAKE_PER_SECOND([]);
    return result[0] as bigint; // TODO verify
  }

  async minStake(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.minStake) return this.cache.minStake;

    const contract = this.ratingsContract;

    const result = await contract.read.MIN_STAKE([]);
    return result[0] as bigint; // TODO verify
  }

  async submitRating(uri: string, score: number, stake: bigint) {
    if (!this.isConnected() || !this.ratingsContract || !this.chain)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.submitRating([uriHash, score], {
      value: stake,
      chain: this.chain,
      account: this.account,
    });
  }

  async removeRating(uri: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.removeRating([uriHash], {
      chain: this.chain,
      account: this.account,
    });
  }

  async cleanupRating(uri: string, rater: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.cleanupRating([uriHash, rater], {
      chain: this.chain,
      account: this.account,
    });
  }

  async getRating(uri: string, rater: string): Promise<Rating | null> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    const contract = this.ratingsContract;

    const uriHash = hashURI(uri);

    const { score, posted, stake } = (await contract.read.getRating([
      uriHash,
      rater,
    ])) as unknown as RatingStruct;

    const stakePerSecond = await this.stakePerSecond();
    const stakeInWei = stake * stakePerSecond;

    return {
      uriHash,
      decodedURI: uri,
      score,
      posted,
      stake: stakeInWei,
      rater,
      expirationTime: new Date((Number(posted) + Number(stake)) * 1000),
    };
  }

  // TODO return all ratings for given address
  async getUserRatings(_address: string): Promise<Rating[]> {
    // This is a placeholder implementation
    // In a real implementation, you would query events or use an indexer
    return [];
  }

  // TODO return all ratings for given URI
  async getURIRatings(_uri: string): Promise<Rating[]> {
    return [];
  }
}

interface ContractInfo {
  addresses: Record<string, `0x${string}`>;
  abi: any[];
}

interface ContractDeploymentInfo {
  address: `0x${string}`;
  abi: any[];
}

interface RatingStruct {
  score: number;
  posted: bigint;
  stake: bigint;
}

export interface Rating {
  uriHash: string;
  decodedURI?: string;
  score: number;
  posted: bigint;
  stake: bigint;
  rater: string;
  expirationTime: Date;
}

export interface SearchResult {
  uriHash: string;
  decodedURI?: string;
  averageScore: number;
  ratingCount: number;
  topRatings?: Rating[];
  isExpired?: boolean;
}
