import {
  createWalletClient,
  createPublicClient,
  http,
  custom,
  getContract,
  type WalletClient,
  type PublicClient,
  type Chain,
  type Address,
} from "viem";
import { mainnet, sepolia, foundry } from "viem/chains";
import { hashURI } from "../utils/blockchain.utils.js";
import "viem/window";

// Import the deployments file
// This will be automatically generated by the build script
// @ts-ignore - This file will be generated at build time
import deployments from "../../src/deployments.json";

// Supported chains
const chains = [mainnet, sepolia, foundry];

export class BlockchainService {
  // Singleton instance
  private static instance: BlockchainService;

  private walletClient: WalletClient | null = null;
  private publicClient: PublicClient | null = null;
  private account: Address | null = null;
  private chain: Chain | null = null;
  private cache?: { minStake: bigint; stakePerSecond: bigint };
  private hashToURI: Map<string, string> = new Map();

  private watchers: {
    UriRevealed?: () => void;
    RatingSubmitted?: () => void;
    RatingReSubmitted?: () => void;
    RatingRemoved?: () => void;
    RatingCleanedUp?: () => void;
  } = {};

  private accountListeners: Set<() => void> = new Set();
  private chainListeners: Set<() => void> = new Set();

  private constructor() {
    // Setup event listeners for MetaMask etc
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", (accounts: string[]) => {
        console.log("Account changed:", accounts[0]);
        this.account = (accounts[0] as Address) || null;
        this.notifyAccountListeners();
      });

      window.ethereum.on("chainChanged", (chainIdHex: string) => {
        console.log("Chain changed:", chainIdHex);
        const chainId = parseInt(chainIdHex, 16);
        this.setChain(chainId);
        this.notifyChainListeners();
      });
    }
  }

  setChain(chainId: number): void {
    this.cache = undefined;

    const currentChain = chains.find((chain) => chain.id === chainId);
    if (!currentChain) {
      this.chain = null;
      throw new Error(`Chain not found: ${chainId}`);
    }

    this.chain = currentChain;

    this.publicClient = createPublicClient({
      chain: currentChain,
      transport: http(),
    });

    if (window.ethereum)
      this.walletClient = createWalletClient({
        chain: currentChain,
        transport: custom(window.ethereum),
      });
  }

  public static getInstance(): BlockchainService {
    if (!BlockchainService.instance) {
      BlockchainService.instance = new BlockchainService();
    }
    return BlockchainService.instance;
  }

  private notifyAccountListeners() {
    this.accountListeners.forEach((listener) => listener());
  }

  private notifyChainListeners() {
    this.chainListeners.forEach((listener) => listener());
  }

  public onAccountChanged(listener: () => void): () => void {
    this.accountListeners.add(listener);
    return () => this.accountListeners.delete(listener);
  }

  public onChainChanged(listener: () => void): () => void {
    this.chainListeners.add(listener);
    return () => this.chainListeners.delete(listener);
  }

  get ratingsContract() {
    if (!this.isConnected() || !this.chain) throw new Error("Not connected");

    const contractInfo = this.getContractInfo("Ratings", this.chain.id);
    if (!contractInfo)
      throw Error(`ChainRater is not deployed on network ${this.chain.id}`);
    const { address, abi } = contractInfo;

    let client;
    if (this.publicClient && this.walletClient)
      client = {
        public: this.publicClient,
        wallet: this.walletClient,
      };
    else if (this.publicClient) client = this.publicClient;
    else if (this.walletClient) client = this.walletClient;
    else throw new Error("No client available");

    return getContract({
      address,
      abi,
      client,
    });
  }

  // Connection methods
  async connect(): Promise<string> {
    if (!window.ethereum) {
      throw new Error("MetaMask or compatible wallet is required");
    }

    // Create wallet client with MetaMask provider
    this.walletClient = createWalletClient({
      transport: custom(window.ethereum),
    });

    // Request accounts
    const accounts = await this.walletClient.requestAddresses();
    this.account = accounts[0];

    if (!this.account) {
      throw new Error("No accounts found");
    }

    // Get chain ID
    const chainId = await window.ethereum
      .request({ method: "eth_chainId" })
      .then((chainIdHex) => parseInt(chainIdHex as string, 16));

    this.setChain(chainId);

    // Fetch URI mappings
    this.watchURIMappings();
    await this.fetchURIMappings();

    return this.account;
  }

  watchURIMappings(): void {
    if (!this.publicClient || !this.chain) throw new Error("Not connected");

    const contract = this.ratingsContract;

    this.watchers.UriRevealed = this.publicClient.watchContractEvent({
      abi: contract.abi,
      address: contract.address,
      eventName: "UriRevealed",
      strict: true,
      onLogs: (logs) => {
        if (!this.isConnected()) return;
        for (const log of logs) {
          const { uriHash, uri } = (log as any).args as {
            uriHash: string;
            uri: string;
          };
          this.hashToURI.set(uriHash, uri);
        }
      },
    });
  }

  async fetchURIMappings(): Promise<void> {
    if (!this.publicClient || !this.chain) throw new Error("Not connected");

    const contract = this.ratingsContract;

    const logs = await this.publicClient?.getContractEvents({
      abi: contract.abi,
      address: contract.address,
      fromBlock: "earliest",
      toBlock: "latest",
      eventName: "UriRevealed",
    });

    for (const log of logs) {
      const { uriHash, uri } = log.args as { uriHash: string; uri: string };
      this.hashToURI.set(uriHash, uri);
    }
  }

  private getContractInfo(
    contractName: string,
    chainId: number,
  ): ContractDeploymentInfo | null {
    const { contracts } = deployments;
    if (!Object.keys(contracts).includes(contractName)) return null;
    const contract = (contracts as any)[contractName] as ContractInfo;

    const { addresses, abi } = contract;
    if (!Object.keys(addresses).includes(String(chainId))) return null;
    const address = addresses[chainId] as Address;

    return { address, abi };
  }

  async disconnect(): Promise<void> {
    this.walletClient = null;
    this.account = null;
    this.notifyAccountListeners();
  }

  isConnected(): boolean {
    return !!this.account && !!this.walletClient;
  }

  get address(): string | null {
    return this.account;
  }

  get chainId(): number | null {
    return this.chain?.id ?? null;
  }

  async stakePerSecond(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.stakePerSecond) return this.cache.stakePerSecond;

    const contract = this.ratingsContract;

    return contract.read.STAKE_PER_SECOND([]) as unknown as bigint;
  }

  async minStake(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.minStake) return this.cache.minStake;

    const contract = this.ratingsContract;

    return contract.read.MIN_STAKE([]) as unknown as bigint;
  }

  async submitRating(uri: string, score: number, stake: bigint) {
    if (!this.isConnected() || !this.ratingsContract || !this.chain)
      throw new Error("Not connected");

    const txHash = await this.ratingsContract.write.submitRating([uri, score], {
      value: stake,
      chain: this.chain,
      account: this.account,
    });
    await this.publicClient?.waitForTransactionReceipt({ hash: txHash });
  }

  async removeRating(uri: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.removeRating([uriHash], {
      chain: this.chain,
      account: this.account,
    });
  }

  async cleanupRating(uri: string, rater: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.cleanupRating([uriHash, rater], {
      chain: this.chain,
      account: this.account,
    });
  }

  async getRating(uri: string, rater: string): Promise<Rating | null> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    const contract = this.ratingsContract;

    const uriHash = hashURI(uri);

    const { score, posted, stake } = (await contract.read.getRating([
      uriHash,
      rater,
    ])) as unknown as RatingStruct;

    const stakePerSecond = await this.stakePerSecond();
    const stakeInWei = stake * stakePerSecond;

    return {
      uriHash,
      decodedURI: uri,
      score,
      posted,
      stake: stakeInWei,
      rater,
      expirationTime: new Date((Number(posted) + Number(stake)) * 1000),
    };
  }

  async getUserRatings(rater: Address): Promise<Rating[]> {
    if (!this.publicClient || !this.chain) throw new Error("Not connected");

    const contract = this.ratingsContract;

    const logs = await this.publicClient?.getContractEvents({
      abi: contract.abi,
      address: contract.address,
      fromBlock: "earliest",
      toBlock: "latest",
      args: {
        rater,
      },
    });

    const events: Record<string, RatingLog> = {};
    for (const log of logs) {
      const { blockNumber } = log;
      const add =
        log.eventName === "RatingSubmitted" ||
        log.eventName === "RatingReSubmitted";
      const {
        rater,
        score,
        stake,
        uri: uriHash,
      }: {
        rater: Address;
        score: number;
        stake: bigint;
        uri: string;
      } = log.args as any;

      // We already have a newer log
      const event = events[uriHash];
      if (event && event.blockNumber > blockNumber) continue;

      // New or newer log
      events[uriHash] = {
        uriHash,
        rater,
        score,
        stake,
        blockNumber,
        add,
      };
    }

    const ratings: Rating[] = [];
    for (const uriHash in events) {
      const event = events[uriHash];
      if (!event.add) continue;

      const rating = await this.getRating(event.uriHash, event.rater);
      if (!rating)
        throw new Error(`Rating not found: ${rater}/${event.uriHash}`);

      ratings.push({
        uriHash,
        rater: event.rater,
        score: event.score,
        stake: event.stake,
        posted: rating.posted,
        expirationTime: rating.expirationTime,
        decodedURI: this.hashToURI.get(uriHash),
      });
    }
    return ratings;
  }

  async getURIRatings(uri: string): Promise<Rating[]> {
    if (!this.publicClient || !this.chain) throw new Error("Not connected");

    const contractInfo = this.getContractInfo("Ratings", this.chain.id);
    if (!contractInfo)
      throw new Error(`Contract not deployed on network ${this.chain.id}`);

    const uriHash = hashURI(uri);

    try {
      // Filter for RatingSubmitted events where the URI matches
      const events = await this.publicClient.getContractEvents({
        address: contractInfo.address,
        abi: contractInfo.abi,
        eventName: "RatingSubmitted",
        args: {
          uri: uriHash,
        },
        fromBlock: "earliest",
        toBlock: "latest",
      });

      // Filter for RatingRemoved events to exclude removed ratings
      const removedEvents = await this.publicClient.getContractEvents({
        address: contractInfo.address,
        abi: contractInfo.abi,
        eventName: "RatingRemoved",
        args: {
          uri: uriHash,
        },
        fromBlock: "earliest",
        toBlock: "latest",
      });

      // Create a set of removed rater addresses for this URI
      const removedRaters = new Set(
        removedEvents.map((event) => (event.args as any).rater as string),
      );

      // Process and transform the events into Rating objects
      const ratings: Rating[] = [];

      for (const event of events) {
        const { uri, rater } = event.args as any;

        // Skip if this rating was removed
        if (removedRaters.has(rater)) continue;

        // Get the full rating data from the contract
        try {
          const rating = await this.getRating(uri, rater);
          if (rating) {
            ratings.push(rating);
          }
        } catch (error) {
          console.warn(
            `Error fetching rating details for rater ${rater}:`,
            error,
          );
          // Continue with next rating if one fails
        }
      }

      return ratings;
    } catch (error) {
      console.error("Error fetching URI ratings:", error);
      throw error;
    }
  }
}

interface ContractInfo {
  addresses: Record<string, `0x${string}`>;
  abi: any[];
}

interface ContractDeploymentInfo {
  address: `0x${string}`;
  abi: any[];
}

interface RatingStruct {
  score: number;
  posted: bigint;
  stake: bigint;
}

export interface Rating {
  uriHash: string;
  decodedURI?: string;
  score: number;
  posted: bigint;
  stake: bigint;
  rater: string;
  expirationTime: Date;
}

export interface SearchResult {
  uriHash: string;
  decodedURI?: string;
  averageScore: number;
  ratingCount: number;
  topRatings?: Rating[];
  isExpired?: boolean;
  stake?: string;
  expirationTime?: Date;
  rater?: string;
}

export interface RatingLog {
  uriHash: string;
  rater: string;
  score: number;
  stake: bigint;
  blockNumber: bigint;
  add: boolean; // true if Rating(Re)Submitted, false otherwise
}
