import {
  createWalletClient,
  createPublicClient,
  http,
  custom,
  getContract,
  type WalletClient,
  type PublicClient,
  type Chain,
  type Address,
  ContractEventName,
  ContractEventArgs,
} from "viem";
import { mainnet, sepolia, foundry } from "viem/chains";
import { hashURI } from "../utils/blockchain.utils.js";
import "viem/window";

// Import the deployments file
// This will be automatically generated by the build script
import deploymentsRaw from "../../src/deployments.json" with { type: "json" };
const deployments = { ...deploymentsRaw } as const;

// type Contract =
// (typeof deployments.contracts)[keyof typeof deployments.contracts];

// Supported chains
const chains = [mainnet, sepolia, foundry];
type CHAIN_IDS = (typeof chains)[number]["id"];
// type CHAIN_IDS = `${(typeof chains)[number]["id"]}`;

export class BlockchainService {
  // Singleton instance
  private static instance: BlockchainService;

  private walletClient: WalletClient | null = null;
  private publicClient: PublicClient | null = null;
  private account: Address | null = null;
  private chain: Chain | null = null;
  private readonly cache: Cache = new Cache();

  private watchers: {
    UriRevealed?: () => void;
    RatingSubmitted?: () => void;
    RatingReSubmitted?: () => void;
    RatingRemoved?: () => void;
    RatingCleanedUp?: () => void;
  } = {};

  private accountListeners: Set<() => void> = new Set();
  private chainListeners: Set<() => void> = new Set();

  private constructor() {
    // Setup event listeners for MetaMask etc
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", (accounts: string[]) => {
        console.log("Account changed:", accounts[0]);
        this.account = (accounts[0] as Address) || null;
        this.notifyAccountListeners();
      });

      window.ethereum.on("chainChanged", (chainIdHex: string) => {
        console.log("Chain changed:", chainIdHex);
        const chainId = parseInt(chainIdHex, 16);
        // TODO handle the change without bad state
        //      1. tell watchers to stop
        //      2. wait for them to do so (if needed)
        //      3. wipe cache and hashToURI
        this.setChain(chainId);
        this.notifyChainListeners();
      });
    }
  }

  async getRatings(filter: GetRatingsFilter): Promise<Rating[]> {
    if (!this.isConnected() || !this.chain) throw new Error("Not connected");
    if (filter.expired !== undefined) await this.stakePerSecond();
    return this.cache.getRatings(filter);
  }

  setChain(chainId: number): void {
    this.cache.clear();

    const currentChain = chains.find((chain) => chain.id === chainId);
    if (!currentChain) {
      this.chain = null;
      throw new Error(`Chain not found: ${chainId}`);
    }

    this.chain = currentChain;

    this.publicClient = createPublicClient({
      chain: currentChain,
      transport: http(),
    });

    if (window.ethereum)
      this.walletClient = createWalletClient({
        chain: currentChain,
        transport: custom(window.ethereum),
      });
  }

  public static getInstance(): BlockchainService {
    if (!BlockchainService.instance) {
      BlockchainService.instance = new BlockchainService();
    }
    return BlockchainService.instance;
  }

  private notifyAccountListeners() {
    this.accountListeners.forEach((listener) => listener());
  }

  private notifyChainListeners() {
    this.chainListeners.forEach((listener) => listener());
  }

  public onAccountChanged(listener: () => void): () => void {
    this.accountListeners.add(listener);
    return () => this.accountListeners.delete(listener);
  }

  public onChainChanged(listener: () => void): () => void {
    this.chainListeners.add(listener);
    return () => this.chainListeners.delete(listener);
  }

  get ratingsContract() {
    if (!this.isConnected() || !this.chain) throw new Error("Not connected");

    const abi = deployments.contracts.Ratings.abi;
    const address = addressOrThrow(
      deployments.contracts.Ratings.addresses,
      this.chain.id,
    );

    return getContract({
      address,
      abi,
      client: this.getClientForContract(),
    });
  }

  private getClientForContract() {
    let client;
    if (this.publicClient && this.walletClient)
      client = {
        public: this.publicClient,
        wallet: this.walletClient,
      };
    else if (this.publicClient) client = this.publicClient;
    else if (this.walletClient) client = this.walletClient;
    else throw new Error("No client available");
    return client;
  }

  // Connection methods
  async connect(): Promise<string> {
    if (!window.ethereum) {
      throw new Error("MetaMask or compatible wallet is required");
    }

    // Create wallet client with MetaMask provider
    this.walletClient = createWalletClient({
      transport: custom(window.ethereum),
    });

    // Request accounts
    const accounts = await this.walletClient.requestAddresses();
    this.account = accounts[0];

    if (!this.account) {
      throw new Error("No accounts found");
    }

    // Get chain ID
    const chainId = await window.ethereum
      .request({ method: "eth_chainId" })
      .then((chainIdHex) => parseInt(chainIdHex as string, 16));

    this.setChain(chainId);

    await Promise.all([this.minStake(), this.stakePerSecond()]);

    if (!this.publicClient) throw new Error("No public client available");

    this.watchers.UriRevealed = RatingsContract.handleEvent(
      this.publicClient,
      "UriRevealed",
      {},
      (logs) => {
        if (!this.isConnected()) return;
        for (const log of logs) {
          const { uriHash, uri } = (log as any).args as Log.UriRevealed;
          this.cache.setUriHash(uri, uriHash);
        }
      },
    );

    const handleAdderLogs = (logs: any[]) => {
      if (!this.isConnected()) return;
      for (const log of logs) {
        const { blockNumber } = log;
        const { uriHash, rater, score, stake } =
          log.args as Log.RatingSubmitted;

        const rating = this.cache.getRatings({ uriHash, rater })[0];

        if (!rating || rating.latestBlockNumber < blockNumber) {
          this.cache.setRating({
            uriHash,
            rater,
            score,
            stake,
            latestBlockNumber: blockNumber,
            posted: stake,
            deleted: false,
          });
        }
      }
    };

    const handleRemoverLogs = (logs: any[]) => {
      if (!this.isConnected()) return;
      for (const log of logs) {
        const { blockNumber }: { blockNumber: bigint } = log;
        const { uriHash, rater } = log.args as Log.RatingRemoved;

        const rating = this.cache.getRatings({ uriHash, rater })[0];

        if (!rating || rating.latestBlockNumber < blockNumber) {
          this.cache.setRating({
            uriHash,
            rater,
            latestBlockNumber: blockNumber,
            deleted: true,
          });
        }
      }
    };

    RatingsContract.handleEvent(
      this.publicClient,
      "RatingSubmitted",
      {},
      handleAdderLogs,
    );
    RatingsContract.handleEvent(
      this.publicClient,
      "RatingReSubmitted",
      {},
      handleAdderLogs,
    );
    RatingsContract.handleEvent(
      this.publicClient,
      "RatingRemoved",
      {},
      handleRemoverLogs,
    );
    RatingsContract.handleEvent(
      this.publicClient,
      "RatingCleanedUp",
      {},
      handleRemoverLogs,
    );

    return this.account;
  }

  handleURIMappings(): void {
    if (!this.publicClient || !this.chain) throw new Error("Not connected");

    const abi = deployments.contracts.Ratings.abi;
    const address = addressOrThrow(
      deployments.contracts.Ratings.addresses,
      this.chain.id,
    );

    const handleLogs = (logs: any[]) => {
      if (!this.isConnected()) return;
      for (const log of logs) {
        const { uriHash, uri } = (log as any).args as Log.UriRevealed;
        this.cache.setUriHash(uri, uriHash);
      }
    };

    // First, watch for new events
    this.watchers.UriRevealed = this.publicClient.watchContractEvent({
      abi,
      address,
      eventName: "UriRevealed",
      strict: true,
      onLogs: (logs) => {
        if (!this.isConnected()) return;
        handleLogs(logs);
      },
    });

    // Then, get the historical events
    this.publicClient
      ?.getContractEvents({
        abi,
        address,
        fromBlock: "earliest",
        toBlock: "latest",
        eventName: "UriRevealed",
      })
      .then(handleLogs);
  }

  async disconnect(): Promise<void> {
    this.walletClient = null;
    this.account = null;
    this.notifyAccountListeners();
  }

  isConnected(): boolean {
    return !!this.account && !!this.walletClient && !!this.chain;
  }

  get address(): Address | null {
    return this.account;
  }

  get chainId(): number | null {
    return this.chain?.id ?? null;
  }

  async stakePerSecond(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.stakePerSecond) return this.cache.stakePerSecond;

    const contract = this.ratingsContract;

    return contract.read.STAKE_PER_SECOND([]) as unknown as bigint;
  }

  async minStake(): Promise<bigint> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    if (this.cache?.minStake) return this.cache.minStake;

    const contract = this.ratingsContract;

    return contract.read.MIN_STAKE([]) as unknown as bigint;
  }

  async submitRating(uri: string, score: number, stake: bigint) {
    if (!this.isConnected() || !this.ratingsContract || !this.chain)
      throw new Error("Not connected");

    const txHash = await this.ratingsContract.write.submitRating([uri, score], {
      value: stake,
      chain: this.chain,
      account: this.account,
    });
    await this.publicClient?.waitForTransactionReceipt({ hash: txHash });
  }

  async removeRating(uri: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.removeRating([uriHash], {
      chain: this.chain,
      account: this.account,
    });
  }

  async cleanupRating(uri: string, rater: string) {
    if (!this.isConnected() || !this.ratingsContract)
      throw new Error("Not connected");

    const uriHash = hashURI(uri);

    await this.ratingsContract.write.cleanupRating([uriHash, rater], {
      chain: this.chain,
      account: this.account,
    });
  }

  async getRating(
    uri: string,
    rater: string,
  ): Promise<Omit<ExistingRating, "latestBlockNumber"> | null> {
    if (!this.publicClient || !this.chainId) throw new Error("Not connected");

    const contract = this.ratingsContract;

    const uriHash = hashURI(uri);

    const { score, posted, stake } = (await contract.read.getRating([
      uriHash,
      rater,
    ])) as unknown as RatingStruct;

    const stakePerSecond = await this.stakePerSecond();
    const stakeInWei = stake * stakePerSecond;

    return {
      uriHash,
      decodedURI: uri,
      score,
      posted,
      stake: stakeInWei,
      rater,
      deleted: false,
    };
  }

  // async getUserRatings(rater: Address): Promise<Rating[]> {
  //   if (!this.publicClient || !this.chain) throw new Error("Not connected");

  //   const contract = this.ratingsContract;

  //   const ratingSubmittedLogs = await this.publicClient?.getContractEvents({
  //     abi: contract.abi,
  //     eventName: "RatingSubmitted",
  //     address: contract.address,
  //     fromBlock: "earliest",
  //     toBlock: "latest",
  //     strict: true,
  //     args: {
  //       rater,
  //     },
  //   });

  //   const events: Record<string, RatingLog> = {};
  //   for (const log of logs) {
  //     console.log(log);
  //     const { blockNumber, eventName } = log as any;
  //     const add =
  //       eventName === "RatingSubmitted" || eventName === "RatingReSubmitted";
  //     const {
  //       rater,
  //       score,
  //       stake,
  //       uri: uriHash,
  //     }: {
  //       rater: Address;
  //       score: number;
  //       stake: bigint;
  //       uri: string;
  //     } = (log as any).args;

  //     // We already have a newer log
  //     const event = events[uriHash];
  //     if (event && event.blockNumber > blockNumber) continue;

  //     // New or newer log
  //     events[uriHash] = {
  //       uriHash,
  //       rater,
  //       score,
  //       stake,
  //       blockNumber,
  //       add,
  //     };
  //   }

  //   const ratings: Rating[] = [];
  //   for (const uriHash in events) {
  //     const event = events[uriHash];
  //     if (!event.add) continue;

  //     const rating = await this.getRating(event.uriHash, event.rater);
  //     if (!rating)
  //       throw new Error(`Rating not found: ${rater}/${event.uriHash}`);

  //     ratings.push({
  //       uriHash,
  //       rater: event.rater,
  //       score: event.score,
  //       stake: event.stake,
  //       posted: rating.posted,
  //       expirationTime: rating.expirationTime,
  //       decodedURI: this.hashToURI.get(uriHash),
  //     });
  //   }
  //   return ratings;
  // }

  // async getURIRatings(uri: string): Promise<Rating[]> {
  //   if (!this.publicClient || !this.chain) throw new Error("Not connected");

  //   const contractInfo = this.getContractInfo("Ratings", this.chain.id);
  //   if (!contractInfo)
  //     throw new Error(`Contract not deployed on network ${this.chain.id}`);

  //   const uriHash = hashURI(uri);

  //   try {
  //     // Filter for RatingSubmitted events where the URI matches
  //     const events = await this.publicClient.getContractEvents({
  //       address: contractInfo.address,
  //       abi: contractInfo.abi,
  //       eventName: "RatingSubmitted",
  //       args: {
  //         uri: uriHash,
  //       },
  //       fromBlock: "earliest",
  //       toBlock: "latest",
  //     });

  //     // Filter for RatingRemoved events to exclude removed ratings
  //     const removedEvents = await this.publicClient.getContractEvents({
  //       address: contractInfo.address,
  //       abi: contractInfo.abi,
  //       eventName: "RatingRemoved",
  //       args: {
  //         uri: uriHash,
  //       },
  //       fromBlock: "earliest",
  //       toBlock: "latest",
  //     });

  //     // Create a set of removed rater addresses for this URI
  //     const removedRaters = new Set(
  //       removedEvents.map((event) => (event.args as any).rater as string),
  //     );

  //     // Process and transform the events into Rating objects
  //     const ratings: Rating[] = [];

  //     for (const event of events) {
  //       const { uri, rater } = event.args as any;

  //       // Skip if this rating was removed
  //       if (removedRaters.has(rater)) continue;

  //       // Get the full rating data from the contract
  //       try {
  //         const rating = await this.getRating(uri, rater);
  //         if (rating) {
  //           ratings.push(rating);
  //         }
  //       } catch (error) {
  //         console.warn(
  //           `Error fetching rating details for rater ${rater}:`,
  //           error,
  //         );
  //         // Continue with next rating if one fails
  //       }
  //     }

  //     return ratings;
  //   } catch (error) {
  //     console.error("Error fetching URI ratings:", error);
  //     throw error;
  //   }
  // }
}

class Cache {
  minStake?: bigint;
  stakePerSecond?: bigint;
  private hashToURI: Map<string, string> = new Map();
  // URI hash -> rater address -> Rating
  private ratings: Map<string, Map<Address, Rating>> = new Map();

  clear() {
    this.minStake = undefined;
    this.stakePerSecond = undefined;
    this.hashToURI.clear();
    this.ratings.clear();
  }

  setUriHash(uri: string, hash?: string) {
    hash = hash ?? hashURI(uri);
    this.hashToURI.set(hash, uri);
  }

  getUriHash(uri: string): string | undefined {
    return this.hashToURI.get(hashURI(uri));
  }

  setRating(rating: Rating) {
    if (!this.ratings.has(rating.uriHash))
      this.ratings.set(rating.uriHash, new Map());
  }

  getRatings({
    uriHash,
    uri,
    rater,
    expired,
    deleted,
  }: GetRatingsFilter): Rating[] {
    if (expired !== undefined && deleted !== false)
      throw new Error("Cannot filter by both expired if deleted != false");

    const filterOnURI = !!uriHash || !!uri;

    let ratings: Rating[] = [];

    if ((uriHash || uri) && rater) {
      uriHash = uriHash ?? hashURI(uri as string);
      const rating = this.ratings.get(uriHash)?.get(rater);
      if (rating) ratings.push(rating);
    }

    this.ratings.forEach((raterMap, ratingUriHash) => {
      if (filterOnURI && ratingUriHash !== uriHash) return;
      raterMap.forEach((rating) => {
        if (rater && rater !== rating.rater) return;
        ratings.push(rating);
      });
    });

    if (deleted !== undefined)
      ratings = ratings.filter((rating) => rating.deleted === deleted);

    if (expired !== undefined) {
      const stakePerSecond = this.stakePerSecond;
      if (stakePerSecond === undefined) throw Error("stakePerSecond not set");
      const now = new Date(); // TODO must be same tz etc as blockchain
      ratings = ratings.filter((rating) => {
        const { posted, stake } = rating as ExistingRating;
        const expirationTime = calculateExpirationTime(
          posted,
          stake,
          stakePerSecond,
        );
        return expired ? expirationTime < now : expirationTime >= now;
      });
    }

    return ratings;
  }

  // getRating(uriOrHash: string, rater: Address): Rating | undefined {
  //   const uriHash = uriOrHash.startsWith("0x") ? uriOrHash : hashURI(uriOrHash);
  //   const raterMap = this.ratings.get(uriHash);
  //   if (!raterMap) return undefined;
  //   return raterMap.get(rater);
  // }

  // getRatingsForURI(uri: string): Rating[] {
  //   const uriHash = hashURI(uri);
  //   const ratings = this.ratings.get(uriHash);
  //   return ratings ? Array.from(ratings.values()) : [];
  // }

  // getRatingsForRater(rater: Address): Rating[] {
  //   const ratings: Rating[] = [];
  //   this.ratings.forEach((raterMap) => {
  //     const rating = raterMap.get(rater);
  //     if (rating) ratings.push(rating);
  //   });
  //   return ratings;
  // }
}

type GetRatingsFilter = {
  uriHash?: string;
  uri?: string;
  rater?: Address;
  expired?: boolean;
  deleted?: boolean;
};

namespace RatingsContract {
  export function handleEvent<
    ABI extends typeof deployments.contracts.Ratings.abi,
  >(
    publicClient: PublicClient,
    eventName: ContractEventName<ABI>,
    args: ContractEventArgs<ABI, typeof eventName>,
    handleLogs: (logs: any[]) => Promise<void> | void,
  ): () => void {
    const chain = publicClient.chain;
    if (!chain) throw new Error("No chain connected");

    const abi = deployments.contracts.Ratings.abi;
    const address = addressOrThrow(
      deployments.contracts.Ratings.addresses,
      chain.id,
    );

    // First, watch for new events
    const stopWatching = publicClient.watchContractEvent({
      abi,
      address,
      eventName,
      args,
      strict: true,
      onLogs: (logs) => {
        handleLogs(logs);
      },
    });

    // Then, get the historical events
    publicClient
      ?.getContractEvents({
        abi,
        address,
        fromBlock: "earliest",
        toBlock: "latest",
        eventName,
      })
      .then(handleLogs);

    return stopWatching;
  }
}

function isChainId(id: number): id is CHAIN_IDS {
  return chains.some((chain) => chain.id === id);
}

function addressOrThrow(addresses: any, id: number): Address {
  if (!isChainId(id)) throw new Error(`Invalid chain ID: ${id}`);

  if (typeof addresses !== "object")
    throw new Error("Invalid deployments file format");
  const addrs = addresses as { [k: string]: Address };
  const address = addrs[String(id)];
  if (!address) throw new Error(`Contract not deployed on network ${id}`);
  if (typeof address !== "string")
    throw new Error("Invalid deployments file format");
  if (!address.startsWith("0x"))
    throw new Error("Invalid deployments file format");
  return address;
}

export function calculateExpirationTime(
  posted: bigint,
  stake: bigint,
  stakePerSecond: bigint,
): Date {
  const expirationTimeInSeconds =
    Number(posted) + Number(stake) / Number(stakePerSecond);
  return new Date(expirationTimeInSeconds * 1000);
}

namespace Log {
  export type UriRevealed = {
    uriHash: string;
    uri: string;
  };
  // Also works for RatingReSubmitted
  export type RatingSubmitted = {
    uriHash: string;
    rater: Address;
    score: number;
    stake: bigint;
  };
  // Also works for RatingCleanedUp
  export type RatingRemoved = {
    uriHash: string;
    rater: Address;
  };
}

interface RatingStruct {
  score: number;
  posted: bigint;
  stake: bigint;
}

export type Rating = ExistingRating | DeletedRating;

export interface ExistingRating {
  uriHash: string;
  decodedURI?: string; // TODO needed?
  score: number;
  posted: bigint;
  stake: bigint;
  rater: string;
  // expirationTime: Date; // TODO derive at-need
  latestBlockNumber: bigint;
  deleted: false;
}

export interface DeletedRating {
  uriHash: string;
  rater: string;
  latestBlockNumber: bigint;
  deleted: true;
}

export interface SearchResult {
  uriHash: string;
  decodedURI?: string;
  averageScore: number;
  ratingCount: number;
  topRatings?: Rating[];
  isExpired?: boolean;
  stake?: string;
  expirationTime?: Date;
  rater?: string;
}

export interface RatingLog {
  uriHash: string;
  rater: string;
  score: number;
  stake: bigint;
  blockNumber: bigint;
  add: boolean; // true if Rating(Re)Submitted, false otherwise
}
